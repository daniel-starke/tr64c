/**
 * @file parser.h
 * @author Daniel Starke
 * @see parser.c
 * @see sax.c
 * @date 2018-06-23
 * @version 2018-07-30
 * 
 * DISCLAIMER
 * This file has no copyright assigned and is placed in the Public Domain.
 * All contributions are also assumed to be in the Public Domain.
 * Other contributions are not permitted.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
 * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
#ifndef __LIBPCF_PARSER_H__
#define __LIBPCF_PARSER_H__

#include <stddef.h>


#ifdef __cplusplus
extern "C" {
#endif


/**
 * Possible token types generated by p_sax().
 */
typedef enum {
	PSTT_PARSE_XML,            /**< test whether the attribute list shall be parsed for the XML processing instruction */
	PSTT_PARSE_INSTRUCTION,    /**< test whether the attribute list shall be parsed for this processing instruction */
	PSTT_XML,                  /**< XML specific processing instruction */
	PSTT_START_TAG,            /**< start tag name */
	PSTT_END_TAG,              /**< end tag name */
	PSTT_INSTRUCTION,          /**< processing instruction */
	PSTT_ATTRIBUTE,            /**< a single argument consisting of argument name and argument value */
	PSTT_CONTENT,              /**< tag content */
	PSTT_CDATA                 /**< CDATA content */
} tPSaxTokenType;


/**
 * Possible return values generated by p_sax().
 */
typedef enum {
	PSRT_SUCCESS,              /**< input XML was parsed successfully */
	PSRT_ABORT,                /**< callback function aborted the parsing operation */
	PSRT_INVALID_ARGUMENT,     /**< an invalid argument was passed to p_sax() */
	PSRT_UNEXPECTED_CHARACTER, /**< unexpected character at the error position */
	PSRT_UNEXPECTED_END,       /**< the XML ends unexpected */
	PSRT_EXPECTED_TAG_NAME,    /**< expected a tag name here */
	PSRT_EXPECTED_TAG_END,     /**< expected the end of the start tag here */
	PSRT_EXPECTED_ANY_TAG_END, /**< expected the and of the start or end tag here */
	PSRT_EXPECTED_ATTR_NAME,   /**< expected a attribute name or tag end here */
	PSRT_EXPECTED_ATTR_EQUAL,  /**< expected attribute value assigning equal sign here */
	PSRT_EXPECTED_ATTR_VALUE,  /**< expected the attribute value here */
	PSRT_EXPECTED_PI_END       /**< expected the end of the processing instruction here */
} tPSaxReturnType;


/**
 * Possible token types generated by p_url().
 */
typedef enum {
	PUTT_PROTOCOL,             /**< protocol */
	PUTT_USER,                 /**< user name */
	PUTT_PASS,                 /**< password */
	PUTT_HOST,                 /**< host name */
	PUTT_PORT,                 /**< port */
	PUTT_PATH,                 /**< path name */
	PUTT_SEARCH,               /**< search */
	PUTT_HASH                  /**< hash */
} tPUrlTokenType;


/**
 * Possible return values generated by p_url().
 */
typedef enum {
	PURT_SUCCESS,              /**< input URL was parsed successfully */
	PURT_ABORT,                /**< callback function aborted the parsing operation */
	PURT_INVALID_ARGUMENT      /**< an invalid argument was passed to p_url() */
} tPUrlReturnType;


/**
 * Possible token types generated by p_http(). They are given in this order.
 */
typedef enum {
	PHTT_REQUEST,              /**< HTTP request line tokens (method, target, version) */
	PHTT_STATUS,               /**< HTTP status line tokens (version, status) */
	PHTT_PARAMETER,            /**< HTTP parameter as key/value pair */
	/**
	 * The expected complete HTTP message (including header) if Content-Length was given.
	 * Note that the length of the passed token may exceed the original HTTP message bounds.
	 */
	PHTT_EXPECTED,
	PHTT_BODY                  /**< HTTP body */
} tPHttpTokenType;


/**
 * Possible return values generated by p_http().
 */
typedef enum {
	PHRT_SUCCESS,                /**< input HTTP request was parsed successfully */
	PHRT_ABORT,                  /**< callback function aborted the parsing operation */
	PHRT_INVALID_ARGUMENT,       /**< an invalid argument was passed to p_http() */
	PHRT_INVALID_CONTENT_LENGTH, /**< the HTTP Content-Length field is invalid */
	PHRT_UNEXPECTED_CHARACTER,   /**< unexpected character at the error position */
	PHRT_UNEXPECTED_END          /**< the HTTP request ends unexpected */
} tPHttpReturnType;


/**
 * A single text parser token.
 */
typedef struct {
	const char * start;        /**< pointer to the start of the token */
	size_t length;             /**< number of bytes length of the token */
} tPToken;


/**
 * A text parser position.
 */
typedef struct {
	size_t line;               /**< position as line number starting at 0 */
	size_t column;             /**< UTF-8 character (not byte) position as column number starting at 0 */
	const char * front;        /**< pointer to the start of the current line */
} tParserPos;


/**
 * Internal helper structure to map XML escape codes to their unescaped strings.
 * 
 * @see p_cmpXmlUnEscMapEntities() and p_unescapeXml()
 */
typedef struct {
	const char * str;
	size_t strSize;
	const char * repl;
	size_t replSize;
} tPXmlUnEscMapEntity;


/**
 * Callback function signature expected by the p_sax() function.
 * 
 * @param[in] type - token type
 * @param[in] tokens - tokens passed (1 for contents and cdata; 2 for xml, instructions and tags, 3 for attributes)
 * @param[in] level - token level (i.e. number of parents)
 * @param[in] param - user defined callback data
 * @return 0 to abort
 * @return 1 to continue
 * @return 2 to continue and parse processing instruction as argument list
 */
typedef int (* PSaxTokenVisitor)(const tPSaxTokenType type, const tPToken * tokens, const size_t level, void * param);


/**
 * Callback function signature expected by the p_url() function.
 * 
 * @param[in] type - token type
 * @param[in] token - token passed
 * @param[in] param - user defined callback data
 * @return 0 to abort
 * @return 1 to continue
 */
typedef int (* PUrlTokenVisitor)(const tPUrlTokenType type, const tPToken * token, void * param);


/**
 * Callback function signature expected by the p_http() function.
 * 
 * @param[in] type - token type
 * @param[in] tokens - tokens passed (1 for body; 2 parameter)
 * @param[in] param - user defined callback data
 * @return 0 to abort
 * @return 1 to continue
 */
typedef int (* PHttpTokenVisitor)(const tPHttpTokenType type, const tPToken * tokens, void * param);


int p_cmpToken(const tPToken * token, const char * str);
int p_cmpTokenI(const tPToken * token, const char * str);
int p_cmpTokens(const tPToken * lhs, const tPToken * rhs);
int p_cmpTokensI(const tPToken * lhs, const tPToken * rhs);
char * p_copyToken(const tPToken * token);
int p_getPos(const char * str, const size_t length, const char * pos, const size_t tabLen, tParserPos * output);

int p_cmpXmlUnEscMapEntities(const void * lhs, const void * rhs);
int p_isXmlNameChar(const int value);
int p_isXmlNameStartChar(const int value);
int p_isXmlWhiteSpace(const int value);
int p_isXmlNeedEscape(const int value);
char * p_escapeXml(const char * str, const size_t length);
int p_escapeXmlVar(char ** var);
char * p_unescapeXml(const char * str, const size_t length, const tPXmlUnEscMapEntity * map, const size_t mapSize);
int p_unescapeXmlVar(char ** var, const tPXmlUnEscMapEntity * map, const size_t mapSize);
int p_xmlGetFullName(tPToken * out, const tPToken * parts);
tPSaxReturnType p_sax(const char * xml, const size_t length, const char ** errorPos, const PSaxTokenVisitor visitor, void * param);

int p_isUrlNeedEscape(const int value);
char * p_escapeUrl(const char * str, const size_t length);
int p_escapeUrlVar(char ** var);
char * p_unescapeUrl(const char * str, const size_t length);
int p_unescapeUrlVar(char ** var);
tPUrlReturnType p_url(const char * str, const size_t length, const PUrlTokenVisitor visitor, void * param);
tPUrlReturnType p_urlTokens(const char * str, const size_t length, tPToken * output);

int p_isHttpTChar(const int value);
int p_isHttpDelimiter(const int value);
tPHttpReturnType p_http(const char * http, const size_t length, const char ** errorPos, const PHttpTokenVisitor visitor, void * param);


#ifdef __cplusplus
}
#endif


#endif /* __LIBPCF_PARSER_H__ */
